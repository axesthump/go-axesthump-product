package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/loms/internal/domain/loms.Repository -o ./mocks/repository_minimock.go -n RepositoryMock

import (
	"context"
	"route256/loms/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements loms.Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCancelOrder          func(ctx context.Context, orderID int64) (err error)
	inspectFuncCancelOrder   func(ctx context.Context, orderID int64)
	afterCancelOrderCounter  uint64
	beforeCancelOrderCounter uint64
	CancelOrderMock          mRepositoryMockCancelOrder

	funcCreateOrder          func(ctx context.Context, order models.OrderData) (i1 int64, err error)
	inspectFuncCreateOrder   func(ctx context.Context, order models.OrderData)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mRepositoryMockCreateOrder

	funcGetStatus          func(ctx context.Context, orderID int64) (o1 models.OrderStatusID, err error)
	inspectFuncGetStatus   func(ctx context.Context, orderID int64)
	afterGetStatusCounter  uint64
	beforeGetStatusCounter uint64
	GetStatusMock          mRepositoryMockGetStatus

	funcListOrder          func(ctx context.Context, orderID int64) (o1 models.OrderInfo, err error)
	inspectFuncListOrder   func(ctx context.Context, orderID int64)
	afterListOrderCounter  uint64
	beforeListOrderCounter uint64
	ListOrderMock          mRepositoryMockListOrder

	funcOrderPayed          func(ctx context.Context, orderID int64) (err error)
	inspectFuncOrderPayed   func(ctx context.Context, orderID int64)
	afterOrderPayedCounter  uint64
	beforeOrderPayedCounter uint64
	OrderPayedMock          mRepositoryMockOrderPayed

	funcReservedItems          func(ctx context.Context, orderID int64) (err error)
	inspectFuncReservedItems   func(ctx context.Context, orderID int64)
	afterReservedItemsCounter  uint64
	beforeReservedItemsCounter uint64
	ReservedItemsMock          mRepositoryMockReservedItems

	funcStocks          func(ctx context.Context, sku uint32) (sa1 []models.Stock, err error)
	inspectFuncStocks   func(ctx context.Context, sku uint32)
	afterStocksCounter  uint64
	beforeStocksCounter uint64
	StocksMock          mRepositoryMockStocks
}

// NewRepositoryMock returns a mock for loms.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CancelOrderMock = mRepositoryMockCancelOrder{mock: m}
	m.CancelOrderMock.callArgs = []*RepositoryMockCancelOrderParams{}

	m.CreateOrderMock = mRepositoryMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*RepositoryMockCreateOrderParams{}

	m.GetStatusMock = mRepositoryMockGetStatus{mock: m}
	m.GetStatusMock.callArgs = []*RepositoryMockGetStatusParams{}

	m.ListOrderMock = mRepositoryMockListOrder{mock: m}
	m.ListOrderMock.callArgs = []*RepositoryMockListOrderParams{}

	m.OrderPayedMock = mRepositoryMockOrderPayed{mock: m}
	m.OrderPayedMock.callArgs = []*RepositoryMockOrderPayedParams{}

	m.ReservedItemsMock = mRepositoryMockReservedItems{mock: m}
	m.ReservedItemsMock.callArgs = []*RepositoryMockReservedItemsParams{}

	m.StocksMock = mRepositoryMockStocks{mock: m}
	m.StocksMock.callArgs = []*RepositoryMockStocksParams{}

	return m
}

type mRepositoryMockCancelOrder struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCancelOrderExpectation
	expectations       []*RepositoryMockCancelOrderExpectation

	callArgs []*RepositoryMockCancelOrderParams
	mutex    sync.RWMutex
}

// RepositoryMockCancelOrderExpectation specifies expectation struct of the Repository.CancelOrder
type RepositoryMockCancelOrderExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCancelOrderParams
	results *RepositoryMockCancelOrderResults
	Counter uint64
}

// RepositoryMockCancelOrderParams contains parameters of the Repository.CancelOrder
type RepositoryMockCancelOrderParams struct {
	ctx     context.Context
	orderID int64
}

// RepositoryMockCancelOrderResults contains results of the Repository.CancelOrder
type RepositoryMockCancelOrderResults struct {
	err error
}

// Expect sets up expected params for Repository.CancelOrder
func (mmCancelOrder *mRepositoryMockCancelOrder) Expect(ctx context.Context, orderID int64) *mRepositoryMockCancelOrder {
	if mmCancelOrder.mock.funcCancelOrder != nil {
		mmCancelOrder.mock.t.Fatalf("RepositoryMock.CancelOrder mock is already set by Set")
	}

	if mmCancelOrder.defaultExpectation == nil {
		mmCancelOrder.defaultExpectation = &RepositoryMockCancelOrderExpectation{}
	}

	mmCancelOrder.defaultExpectation.params = &RepositoryMockCancelOrderParams{ctx, orderID}
	for _, e := range mmCancelOrder.expectations {
		if minimock.Equal(e.params, mmCancelOrder.defaultExpectation.params) {
			mmCancelOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancelOrder.defaultExpectation.params)
		}
	}

	return mmCancelOrder
}

// Inspect accepts an inspector function that has same arguments as the Repository.CancelOrder
func (mmCancelOrder *mRepositoryMockCancelOrder) Inspect(f func(ctx context.Context, orderID int64)) *mRepositoryMockCancelOrder {
	if mmCancelOrder.mock.inspectFuncCancelOrder != nil {
		mmCancelOrder.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CancelOrder")
	}

	mmCancelOrder.mock.inspectFuncCancelOrder = f

	return mmCancelOrder
}

// Return sets up results that will be returned by Repository.CancelOrder
func (mmCancelOrder *mRepositoryMockCancelOrder) Return(err error) *RepositoryMock {
	if mmCancelOrder.mock.funcCancelOrder != nil {
		mmCancelOrder.mock.t.Fatalf("RepositoryMock.CancelOrder mock is already set by Set")
	}

	if mmCancelOrder.defaultExpectation == nil {
		mmCancelOrder.defaultExpectation = &RepositoryMockCancelOrderExpectation{mock: mmCancelOrder.mock}
	}
	mmCancelOrder.defaultExpectation.results = &RepositoryMockCancelOrderResults{err}
	return mmCancelOrder.mock
}

// Set uses given function f to mock the Repository.CancelOrder method
func (mmCancelOrder *mRepositoryMockCancelOrder) Set(f func(ctx context.Context, orderID int64) (err error)) *RepositoryMock {
	if mmCancelOrder.defaultExpectation != nil {
		mmCancelOrder.mock.t.Fatalf("Default expectation is already set for the Repository.CancelOrder method")
	}

	if len(mmCancelOrder.expectations) > 0 {
		mmCancelOrder.mock.t.Fatalf("Some expectations are already set for the Repository.CancelOrder method")
	}

	mmCancelOrder.mock.funcCancelOrder = f
	return mmCancelOrder.mock
}

// When sets expectation for the Repository.CancelOrder which will trigger the result defined by the following
// Then helper
func (mmCancelOrder *mRepositoryMockCancelOrder) When(ctx context.Context, orderID int64) *RepositoryMockCancelOrderExpectation {
	if mmCancelOrder.mock.funcCancelOrder != nil {
		mmCancelOrder.mock.t.Fatalf("RepositoryMock.CancelOrder mock is already set by Set")
	}

	expectation := &RepositoryMockCancelOrderExpectation{
		mock:   mmCancelOrder.mock,
		params: &RepositoryMockCancelOrderParams{ctx, orderID},
	}
	mmCancelOrder.expectations = append(mmCancelOrder.expectations, expectation)
	return expectation
}

// Then sets up Repository.CancelOrder return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCancelOrderExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCancelOrderResults{err}
	return e.mock
}

// CancelOrder implements loms.Repository
func (mmCancelOrder *RepositoryMock) CancelOrder(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmCancelOrder.beforeCancelOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCancelOrder.afterCancelOrderCounter, 1)

	if mmCancelOrder.inspectFuncCancelOrder != nil {
		mmCancelOrder.inspectFuncCancelOrder(ctx, orderID)
	}

	mm_params := &RepositoryMockCancelOrderParams{ctx, orderID}

	// Record call args
	mmCancelOrder.CancelOrderMock.mutex.Lock()
	mmCancelOrder.CancelOrderMock.callArgs = append(mmCancelOrder.CancelOrderMock.callArgs, mm_params)
	mmCancelOrder.CancelOrderMock.mutex.Unlock()

	for _, e := range mmCancelOrder.CancelOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancelOrder.CancelOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancelOrder.CancelOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCancelOrder.CancelOrderMock.defaultExpectation.params
		mm_got := RepositoryMockCancelOrderParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancelOrder.t.Errorf("RepositoryMock.CancelOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancelOrder.CancelOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCancelOrder.t.Fatal("No results are set for the RepositoryMock.CancelOrder")
		}
		return (*mm_results).err
	}
	if mmCancelOrder.funcCancelOrder != nil {
		return mmCancelOrder.funcCancelOrder(ctx, orderID)
	}
	mmCancelOrder.t.Fatalf("Unexpected call to RepositoryMock.CancelOrder. %v %v", ctx, orderID)
	return
}

// CancelOrderAfterCounter returns a count of finished RepositoryMock.CancelOrder invocations
func (mmCancelOrder *RepositoryMock) CancelOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelOrder.afterCancelOrderCounter)
}

// CancelOrderBeforeCounter returns a count of RepositoryMock.CancelOrder invocations
func (mmCancelOrder *RepositoryMock) CancelOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancelOrder.beforeCancelOrderCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CancelOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancelOrder *mRepositoryMockCancelOrder) Calls() []*RepositoryMockCancelOrderParams {
	mmCancelOrder.mutex.RLock()

	argCopy := make([]*RepositoryMockCancelOrderParams, len(mmCancelOrder.callArgs))
	copy(argCopy, mmCancelOrder.callArgs)

	mmCancelOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCancelOrderDone returns true if the count of the CancelOrder invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCancelOrderDone() bool {
	for _, e := range m.CancelOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelOrder != nil && mm_atomic.LoadUint64(&m.afterCancelOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCancelOrderInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCancelOrderInspect() {
	for _, e := range m.CancelOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CancelOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CancelOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCancelOrderCounter) < 1 {
		if m.CancelOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CancelOrder")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CancelOrder with params: %#v", *m.CancelOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancelOrder != nil && mm_atomic.LoadUint64(&m.afterCancelOrderCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CancelOrder")
	}
}

type mRepositoryMockCreateOrder struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateOrderExpectation
	expectations       []*RepositoryMockCreateOrderExpectation

	callArgs []*RepositoryMockCreateOrderParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateOrderExpectation specifies expectation struct of the Repository.CreateOrder
type RepositoryMockCreateOrderExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateOrderParams
	results *RepositoryMockCreateOrderResults
	Counter uint64
}

// RepositoryMockCreateOrderParams contains parameters of the Repository.CreateOrder
type RepositoryMockCreateOrderParams struct {
	ctx   context.Context
	order models.OrderData
}

// RepositoryMockCreateOrderResults contains results of the Repository.CreateOrder
type RepositoryMockCreateOrderResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Repository.CreateOrder
func (mmCreateOrder *mRepositoryMockCreateOrder) Expect(ctx context.Context, order models.OrderData) *mRepositoryMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("RepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &RepositoryMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &RepositoryMockCreateOrderParams{ctx, order}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateOrder
func (mmCreateOrder *mRepositoryMockCreateOrder) Inspect(f func(ctx context.Context, order models.OrderData)) *mRepositoryMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by Repository.CreateOrder
func (mmCreateOrder *mRepositoryMockCreateOrder) Return(i1 int64, err error) *RepositoryMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("RepositoryMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &RepositoryMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &RepositoryMockCreateOrderResults{i1, err}
	return mmCreateOrder.mock
}

// Set uses given function f to mock the Repository.CreateOrder method
func (mmCreateOrder *mRepositoryMockCreateOrder) Set(f func(ctx context.Context, order models.OrderData) (i1 int64, err error)) *RepositoryMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the Repository.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the Repository.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the Repository.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mRepositoryMockCreateOrder) When(ctx context.Context, order models.OrderData) *RepositoryMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("RepositoryMock.CreateOrder mock is already set by Set")
	}

	expectation := &RepositoryMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &RepositoryMockCreateOrderParams{ctx, order},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateOrder return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateOrderExpectation) Then(i1 int64, err error) *RepositoryMock {
	e.results = &RepositoryMockCreateOrderResults{i1, err}
	return e.mock
}

// CreateOrder implements loms.Repository
func (mmCreateOrder *RepositoryMock) CreateOrder(ctx context.Context, order models.OrderData) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, order)
	}

	mm_params := &RepositoryMockCreateOrderParams{ctx, order}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := RepositoryMockCreateOrderParams{ctx, order}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("RepositoryMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the RepositoryMock.CreateOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, order)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to RepositoryMock.CreateOrder. %v %v", ctx, order)
	return
}

// CreateOrderAfterCounter returns a count of finished RepositoryMock.CreateOrder invocations
func (mmCreateOrder *RepositoryMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of RepositoryMock.CreateOrder invocations
func (mmCreateOrder *RepositoryMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mRepositoryMockCreateOrder) Calls() []*RepositoryMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateOrder")
	}
}

type mRepositoryMockGetStatus struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetStatusExpectation
	expectations       []*RepositoryMockGetStatusExpectation

	callArgs []*RepositoryMockGetStatusParams
	mutex    sync.RWMutex
}

// RepositoryMockGetStatusExpectation specifies expectation struct of the Repository.GetStatus
type RepositoryMockGetStatusExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetStatusParams
	results *RepositoryMockGetStatusResults
	Counter uint64
}

// RepositoryMockGetStatusParams contains parameters of the Repository.GetStatus
type RepositoryMockGetStatusParams struct {
	ctx     context.Context
	orderID int64
}

// RepositoryMockGetStatusResults contains results of the Repository.GetStatus
type RepositoryMockGetStatusResults struct {
	o1  models.OrderStatusID
	err error
}

// Expect sets up expected params for Repository.GetStatus
func (mmGetStatus *mRepositoryMockGetStatus) Expect(ctx context.Context, orderID int64) *mRepositoryMockGetStatus {
	if mmGetStatus.mock.funcGetStatus != nil {
		mmGetStatus.mock.t.Fatalf("RepositoryMock.GetStatus mock is already set by Set")
	}

	if mmGetStatus.defaultExpectation == nil {
		mmGetStatus.defaultExpectation = &RepositoryMockGetStatusExpectation{}
	}

	mmGetStatus.defaultExpectation.params = &RepositoryMockGetStatusParams{ctx, orderID}
	for _, e := range mmGetStatus.expectations {
		if minimock.Equal(e.params, mmGetStatus.defaultExpectation.params) {
			mmGetStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetStatus.defaultExpectation.params)
		}
	}

	return mmGetStatus
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetStatus
func (mmGetStatus *mRepositoryMockGetStatus) Inspect(f func(ctx context.Context, orderID int64)) *mRepositoryMockGetStatus {
	if mmGetStatus.mock.inspectFuncGetStatus != nil {
		mmGetStatus.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetStatus")
	}

	mmGetStatus.mock.inspectFuncGetStatus = f

	return mmGetStatus
}

// Return sets up results that will be returned by Repository.GetStatus
func (mmGetStatus *mRepositoryMockGetStatus) Return(o1 models.OrderStatusID, err error) *RepositoryMock {
	if mmGetStatus.mock.funcGetStatus != nil {
		mmGetStatus.mock.t.Fatalf("RepositoryMock.GetStatus mock is already set by Set")
	}

	if mmGetStatus.defaultExpectation == nil {
		mmGetStatus.defaultExpectation = &RepositoryMockGetStatusExpectation{mock: mmGetStatus.mock}
	}
	mmGetStatus.defaultExpectation.results = &RepositoryMockGetStatusResults{o1, err}
	return mmGetStatus.mock
}

// Set uses given function f to mock the Repository.GetStatus method
func (mmGetStatus *mRepositoryMockGetStatus) Set(f func(ctx context.Context, orderID int64) (o1 models.OrderStatusID, err error)) *RepositoryMock {
	if mmGetStatus.defaultExpectation != nil {
		mmGetStatus.mock.t.Fatalf("Default expectation is already set for the Repository.GetStatus method")
	}

	if len(mmGetStatus.expectations) > 0 {
		mmGetStatus.mock.t.Fatalf("Some expectations are already set for the Repository.GetStatus method")
	}

	mmGetStatus.mock.funcGetStatus = f
	return mmGetStatus.mock
}

// When sets expectation for the Repository.GetStatus which will trigger the result defined by the following
// Then helper
func (mmGetStatus *mRepositoryMockGetStatus) When(ctx context.Context, orderID int64) *RepositoryMockGetStatusExpectation {
	if mmGetStatus.mock.funcGetStatus != nil {
		mmGetStatus.mock.t.Fatalf("RepositoryMock.GetStatus mock is already set by Set")
	}

	expectation := &RepositoryMockGetStatusExpectation{
		mock:   mmGetStatus.mock,
		params: &RepositoryMockGetStatusParams{ctx, orderID},
	}
	mmGetStatus.expectations = append(mmGetStatus.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetStatus return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetStatusExpectation) Then(o1 models.OrderStatusID, err error) *RepositoryMock {
	e.results = &RepositoryMockGetStatusResults{o1, err}
	return e.mock
}

// GetStatus implements loms.Repository
func (mmGetStatus *RepositoryMock) GetStatus(ctx context.Context, orderID int64) (o1 models.OrderStatusID, err error) {
	mm_atomic.AddUint64(&mmGetStatus.beforeGetStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmGetStatus.afterGetStatusCounter, 1)

	if mmGetStatus.inspectFuncGetStatus != nil {
		mmGetStatus.inspectFuncGetStatus(ctx, orderID)
	}

	mm_params := &RepositoryMockGetStatusParams{ctx, orderID}

	// Record call args
	mmGetStatus.GetStatusMock.mutex.Lock()
	mmGetStatus.GetStatusMock.callArgs = append(mmGetStatus.GetStatusMock.callArgs, mm_params)
	mmGetStatus.GetStatusMock.mutex.Unlock()

	for _, e := range mmGetStatus.GetStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetStatus.GetStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetStatus.GetStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmGetStatus.GetStatusMock.defaultExpectation.params
		mm_got := RepositoryMockGetStatusParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetStatus.t.Errorf("RepositoryMock.GetStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetStatus.GetStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmGetStatus.t.Fatal("No results are set for the RepositoryMock.GetStatus")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetStatus.funcGetStatus != nil {
		return mmGetStatus.funcGetStatus(ctx, orderID)
	}
	mmGetStatus.t.Fatalf("Unexpected call to RepositoryMock.GetStatus. %v %v", ctx, orderID)
	return
}

// GetStatusAfterCounter returns a count of finished RepositoryMock.GetStatus invocations
func (mmGetStatus *RepositoryMock) GetStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatus.afterGetStatusCounter)
}

// GetStatusBeforeCounter returns a count of RepositoryMock.GetStatus invocations
func (mmGetStatus *RepositoryMock) GetStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetStatus.beforeGetStatusCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetStatus *mRepositoryMockGetStatus) Calls() []*RepositoryMockGetStatusParams {
	mmGetStatus.mutex.RLock()

	argCopy := make([]*RepositoryMockGetStatusParams, len(mmGetStatus.callArgs))
	copy(argCopy, mmGetStatus.callArgs)

	mmGetStatus.mutex.RUnlock()

	return argCopy
}

// MinimockGetStatusDone returns true if the count of the GetStatus invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetStatusDone() bool {
	for _, e := range m.GetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatus != nil && mm_atomic.LoadUint64(&m.afterGetStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetStatusInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetStatusInspect() {
	for _, e := range m.GetStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetStatusCounter) < 1 {
		if m.GetStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetStatus")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetStatus with params: %#v", *m.GetStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetStatus != nil && mm_atomic.LoadUint64(&m.afterGetStatusCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetStatus")
	}
}

type mRepositoryMockListOrder struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockListOrderExpectation
	expectations       []*RepositoryMockListOrderExpectation

	callArgs []*RepositoryMockListOrderParams
	mutex    sync.RWMutex
}

// RepositoryMockListOrderExpectation specifies expectation struct of the Repository.ListOrder
type RepositoryMockListOrderExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockListOrderParams
	results *RepositoryMockListOrderResults
	Counter uint64
}

// RepositoryMockListOrderParams contains parameters of the Repository.ListOrder
type RepositoryMockListOrderParams struct {
	ctx     context.Context
	orderID int64
}

// RepositoryMockListOrderResults contains results of the Repository.ListOrder
type RepositoryMockListOrderResults struct {
	o1  models.OrderInfo
	err error
}

// Expect sets up expected params for Repository.ListOrder
func (mmListOrder *mRepositoryMockListOrder) Expect(ctx context.Context, orderID int64) *mRepositoryMockListOrder {
	if mmListOrder.mock.funcListOrder != nil {
		mmListOrder.mock.t.Fatalf("RepositoryMock.ListOrder mock is already set by Set")
	}

	if mmListOrder.defaultExpectation == nil {
		mmListOrder.defaultExpectation = &RepositoryMockListOrderExpectation{}
	}

	mmListOrder.defaultExpectation.params = &RepositoryMockListOrderParams{ctx, orderID}
	for _, e := range mmListOrder.expectations {
		if minimock.Equal(e.params, mmListOrder.defaultExpectation.params) {
			mmListOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrder.defaultExpectation.params)
		}
	}

	return mmListOrder
}

// Inspect accepts an inspector function that has same arguments as the Repository.ListOrder
func (mmListOrder *mRepositoryMockListOrder) Inspect(f func(ctx context.Context, orderID int64)) *mRepositoryMockListOrder {
	if mmListOrder.mock.inspectFuncListOrder != nil {
		mmListOrder.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ListOrder")
	}

	mmListOrder.mock.inspectFuncListOrder = f

	return mmListOrder
}

// Return sets up results that will be returned by Repository.ListOrder
func (mmListOrder *mRepositoryMockListOrder) Return(o1 models.OrderInfo, err error) *RepositoryMock {
	if mmListOrder.mock.funcListOrder != nil {
		mmListOrder.mock.t.Fatalf("RepositoryMock.ListOrder mock is already set by Set")
	}

	if mmListOrder.defaultExpectation == nil {
		mmListOrder.defaultExpectation = &RepositoryMockListOrderExpectation{mock: mmListOrder.mock}
	}
	mmListOrder.defaultExpectation.results = &RepositoryMockListOrderResults{o1, err}
	return mmListOrder.mock
}

// Set uses given function f to mock the Repository.ListOrder method
func (mmListOrder *mRepositoryMockListOrder) Set(f func(ctx context.Context, orderID int64) (o1 models.OrderInfo, err error)) *RepositoryMock {
	if mmListOrder.defaultExpectation != nil {
		mmListOrder.mock.t.Fatalf("Default expectation is already set for the Repository.ListOrder method")
	}

	if len(mmListOrder.expectations) > 0 {
		mmListOrder.mock.t.Fatalf("Some expectations are already set for the Repository.ListOrder method")
	}

	mmListOrder.mock.funcListOrder = f
	return mmListOrder.mock
}

// When sets expectation for the Repository.ListOrder which will trigger the result defined by the following
// Then helper
func (mmListOrder *mRepositoryMockListOrder) When(ctx context.Context, orderID int64) *RepositoryMockListOrderExpectation {
	if mmListOrder.mock.funcListOrder != nil {
		mmListOrder.mock.t.Fatalf("RepositoryMock.ListOrder mock is already set by Set")
	}

	expectation := &RepositoryMockListOrderExpectation{
		mock:   mmListOrder.mock,
		params: &RepositoryMockListOrderParams{ctx, orderID},
	}
	mmListOrder.expectations = append(mmListOrder.expectations, expectation)
	return expectation
}

// Then sets up Repository.ListOrder return parameters for the expectation previously defined by the When method
func (e *RepositoryMockListOrderExpectation) Then(o1 models.OrderInfo, err error) *RepositoryMock {
	e.results = &RepositoryMockListOrderResults{o1, err}
	return e.mock
}

// ListOrder implements loms.Repository
func (mmListOrder *RepositoryMock) ListOrder(ctx context.Context, orderID int64) (o1 models.OrderInfo, err error) {
	mm_atomic.AddUint64(&mmListOrder.beforeListOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrder.afterListOrderCounter, 1)

	if mmListOrder.inspectFuncListOrder != nil {
		mmListOrder.inspectFuncListOrder(ctx, orderID)
	}

	mm_params := &RepositoryMockListOrderParams{ctx, orderID}

	// Record call args
	mmListOrder.ListOrderMock.mutex.Lock()
	mmListOrder.ListOrderMock.callArgs = append(mmListOrder.ListOrderMock.callArgs, mm_params)
	mmListOrder.ListOrderMock.mutex.Unlock()

	for _, e := range mmListOrder.ListOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmListOrder.ListOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrder.ListOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrder.ListOrderMock.defaultExpectation.params
		mm_got := RepositoryMockListOrderParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrder.t.Errorf("RepositoryMock.ListOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrder.ListOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrder.t.Fatal("No results are set for the RepositoryMock.ListOrder")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmListOrder.funcListOrder != nil {
		return mmListOrder.funcListOrder(ctx, orderID)
	}
	mmListOrder.t.Fatalf("Unexpected call to RepositoryMock.ListOrder. %v %v", ctx, orderID)
	return
}

// ListOrderAfterCounter returns a count of finished RepositoryMock.ListOrder invocations
func (mmListOrder *RepositoryMock) ListOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrder.afterListOrderCounter)
}

// ListOrderBeforeCounter returns a count of RepositoryMock.ListOrder invocations
func (mmListOrder *RepositoryMock) ListOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrder.beforeListOrderCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ListOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrder *mRepositoryMockListOrder) Calls() []*RepositoryMockListOrderParams {
	mmListOrder.mutex.RLock()

	argCopy := make([]*RepositoryMockListOrderParams, len(mmListOrder.callArgs))
	copy(argCopy, mmListOrder.callArgs)

	mmListOrder.mutex.RUnlock()

	return argCopy
}

// MinimockListOrderDone returns true if the count of the ListOrder invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockListOrderDone() bool {
	for _, e := range m.ListOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrder != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockListOrderInspect logs each unmet expectation
func (m *RepositoryMock) MinimockListOrderInspect() {
	for _, e := range m.ListOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ListOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		if m.ListOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ListOrder")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ListOrder with params: %#v", *m.ListOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrder != nil && mm_atomic.LoadUint64(&m.afterListOrderCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ListOrder")
	}
}

type mRepositoryMockOrderPayed struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockOrderPayedExpectation
	expectations       []*RepositoryMockOrderPayedExpectation

	callArgs []*RepositoryMockOrderPayedParams
	mutex    sync.RWMutex
}

// RepositoryMockOrderPayedExpectation specifies expectation struct of the Repository.OrderPayed
type RepositoryMockOrderPayedExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockOrderPayedParams
	results *RepositoryMockOrderPayedResults
	Counter uint64
}

// RepositoryMockOrderPayedParams contains parameters of the Repository.OrderPayed
type RepositoryMockOrderPayedParams struct {
	ctx     context.Context
	orderID int64
}

// RepositoryMockOrderPayedResults contains results of the Repository.OrderPayed
type RepositoryMockOrderPayedResults struct {
	err error
}

// Expect sets up expected params for Repository.OrderPayed
func (mmOrderPayed *mRepositoryMockOrderPayed) Expect(ctx context.Context, orderID int64) *mRepositoryMockOrderPayed {
	if mmOrderPayed.mock.funcOrderPayed != nil {
		mmOrderPayed.mock.t.Fatalf("RepositoryMock.OrderPayed mock is already set by Set")
	}

	if mmOrderPayed.defaultExpectation == nil {
		mmOrderPayed.defaultExpectation = &RepositoryMockOrderPayedExpectation{}
	}

	mmOrderPayed.defaultExpectation.params = &RepositoryMockOrderPayedParams{ctx, orderID}
	for _, e := range mmOrderPayed.expectations {
		if minimock.Equal(e.params, mmOrderPayed.defaultExpectation.params) {
			mmOrderPayed.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrderPayed.defaultExpectation.params)
		}
	}

	return mmOrderPayed
}

// Inspect accepts an inspector function that has same arguments as the Repository.OrderPayed
func (mmOrderPayed *mRepositoryMockOrderPayed) Inspect(f func(ctx context.Context, orderID int64)) *mRepositoryMockOrderPayed {
	if mmOrderPayed.mock.inspectFuncOrderPayed != nil {
		mmOrderPayed.mock.t.Fatalf("Inspect function is already set for RepositoryMock.OrderPayed")
	}

	mmOrderPayed.mock.inspectFuncOrderPayed = f

	return mmOrderPayed
}

// Return sets up results that will be returned by Repository.OrderPayed
func (mmOrderPayed *mRepositoryMockOrderPayed) Return(err error) *RepositoryMock {
	if mmOrderPayed.mock.funcOrderPayed != nil {
		mmOrderPayed.mock.t.Fatalf("RepositoryMock.OrderPayed mock is already set by Set")
	}

	if mmOrderPayed.defaultExpectation == nil {
		mmOrderPayed.defaultExpectation = &RepositoryMockOrderPayedExpectation{mock: mmOrderPayed.mock}
	}
	mmOrderPayed.defaultExpectation.results = &RepositoryMockOrderPayedResults{err}
	return mmOrderPayed.mock
}

// Set uses given function f to mock the Repository.OrderPayed method
func (mmOrderPayed *mRepositoryMockOrderPayed) Set(f func(ctx context.Context, orderID int64) (err error)) *RepositoryMock {
	if mmOrderPayed.defaultExpectation != nil {
		mmOrderPayed.mock.t.Fatalf("Default expectation is already set for the Repository.OrderPayed method")
	}

	if len(mmOrderPayed.expectations) > 0 {
		mmOrderPayed.mock.t.Fatalf("Some expectations are already set for the Repository.OrderPayed method")
	}

	mmOrderPayed.mock.funcOrderPayed = f
	return mmOrderPayed.mock
}

// When sets expectation for the Repository.OrderPayed which will trigger the result defined by the following
// Then helper
func (mmOrderPayed *mRepositoryMockOrderPayed) When(ctx context.Context, orderID int64) *RepositoryMockOrderPayedExpectation {
	if mmOrderPayed.mock.funcOrderPayed != nil {
		mmOrderPayed.mock.t.Fatalf("RepositoryMock.OrderPayed mock is already set by Set")
	}

	expectation := &RepositoryMockOrderPayedExpectation{
		mock:   mmOrderPayed.mock,
		params: &RepositoryMockOrderPayedParams{ctx, orderID},
	}
	mmOrderPayed.expectations = append(mmOrderPayed.expectations, expectation)
	return expectation
}

// Then sets up Repository.OrderPayed return parameters for the expectation previously defined by the When method
func (e *RepositoryMockOrderPayedExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockOrderPayedResults{err}
	return e.mock
}

// OrderPayed implements loms.Repository
func (mmOrderPayed *RepositoryMock) OrderPayed(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmOrderPayed.beforeOrderPayedCounter, 1)
	defer mm_atomic.AddUint64(&mmOrderPayed.afterOrderPayedCounter, 1)

	if mmOrderPayed.inspectFuncOrderPayed != nil {
		mmOrderPayed.inspectFuncOrderPayed(ctx, orderID)
	}

	mm_params := &RepositoryMockOrderPayedParams{ctx, orderID}

	// Record call args
	mmOrderPayed.OrderPayedMock.mutex.Lock()
	mmOrderPayed.OrderPayedMock.callArgs = append(mmOrderPayed.OrderPayedMock.callArgs, mm_params)
	mmOrderPayed.OrderPayedMock.mutex.Unlock()

	for _, e := range mmOrderPayed.OrderPayedMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmOrderPayed.OrderPayedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrderPayed.OrderPayedMock.defaultExpectation.Counter, 1)
		mm_want := mmOrderPayed.OrderPayedMock.defaultExpectation.params
		mm_got := RepositoryMockOrderPayedParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrderPayed.t.Errorf("RepositoryMock.OrderPayed got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrderPayed.OrderPayedMock.defaultExpectation.results
		if mm_results == nil {
			mmOrderPayed.t.Fatal("No results are set for the RepositoryMock.OrderPayed")
		}
		return (*mm_results).err
	}
	if mmOrderPayed.funcOrderPayed != nil {
		return mmOrderPayed.funcOrderPayed(ctx, orderID)
	}
	mmOrderPayed.t.Fatalf("Unexpected call to RepositoryMock.OrderPayed. %v %v", ctx, orderID)
	return
}

// OrderPayedAfterCounter returns a count of finished RepositoryMock.OrderPayed invocations
func (mmOrderPayed *RepositoryMock) OrderPayedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPayed.afterOrderPayedCounter)
}

// OrderPayedBeforeCounter returns a count of RepositoryMock.OrderPayed invocations
func (mmOrderPayed *RepositoryMock) OrderPayedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrderPayed.beforeOrderPayedCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.OrderPayed.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrderPayed *mRepositoryMockOrderPayed) Calls() []*RepositoryMockOrderPayedParams {
	mmOrderPayed.mutex.RLock()

	argCopy := make([]*RepositoryMockOrderPayedParams, len(mmOrderPayed.callArgs))
	copy(argCopy, mmOrderPayed.callArgs)

	mmOrderPayed.mutex.RUnlock()

	return argCopy
}

// MinimockOrderPayedDone returns true if the count of the OrderPayed invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockOrderPayedDone() bool {
	for _, e := range m.OrderPayedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderPayedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderPayedCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderPayed != nil && mm_atomic.LoadUint64(&m.afterOrderPayedCounter) < 1 {
		return false
	}
	return true
}

// MinimockOrderPayedInspect logs each unmet expectation
func (m *RepositoryMock) MinimockOrderPayedInspect() {
	for _, e := range m.OrderPayedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.OrderPayed with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.OrderPayedMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterOrderPayedCounter) < 1 {
		if m.OrderPayedMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.OrderPayed")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.OrderPayed with params: %#v", *m.OrderPayedMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrderPayed != nil && mm_atomic.LoadUint64(&m.afterOrderPayedCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.OrderPayed")
	}
}

type mRepositoryMockReservedItems struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockReservedItemsExpectation
	expectations       []*RepositoryMockReservedItemsExpectation

	callArgs []*RepositoryMockReservedItemsParams
	mutex    sync.RWMutex
}

// RepositoryMockReservedItemsExpectation specifies expectation struct of the Repository.ReservedItems
type RepositoryMockReservedItemsExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockReservedItemsParams
	results *RepositoryMockReservedItemsResults
	Counter uint64
}

// RepositoryMockReservedItemsParams contains parameters of the Repository.ReservedItems
type RepositoryMockReservedItemsParams struct {
	ctx     context.Context
	orderID int64
}

// RepositoryMockReservedItemsResults contains results of the Repository.ReservedItems
type RepositoryMockReservedItemsResults struct {
	err error
}

// Expect sets up expected params for Repository.ReservedItems
func (mmReservedItems *mRepositoryMockReservedItems) Expect(ctx context.Context, orderID int64) *mRepositoryMockReservedItems {
	if mmReservedItems.mock.funcReservedItems != nil {
		mmReservedItems.mock.t.Fatalf("RepositoryMock.ReservedItems mock is already set by Set")
	}

	if mmReservedItems.defaultExpectation == nil {
		mmReservedItems.defaultExpectation = &RepositoryMockReservedItemsExpectation{}
	}

	mmReservedItems.defaultExpectation.params = &RepositoryMockReservedItemsParams{ctx, orderID}
	for _, e := range mmReservedItems.expectations {
		if minimock.Equal(e.params, mmReservedItems.defaultExpectation.params) {
			mmReservedItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReservedItems.defaultExpectation.params)
		}
	}

	return mmReservedItems
}

// Inspect accepts an inspector function that has same arguments as the Repository.ReservedItems
func (mmReservedItems *mRepositoryMockReservedItems) Inspect(f func(ctx context.Context, orderID int64)) *mRepositoryMockReservedItems {
	if mmReservedItems.mock.inspectFuncReservedItems != nil {
		mmReservedItems.mock.t.Fatalf("Inspect function is already set for RepositoryMock.ReservedItems")
	}

	mmReservedItems.mock.inspectFuncReservedItems = f

	return mmReservedItems
}

// Return sets up results that will be returned by Repository.ReservedItems
func (mmReservedItems *mRepositoryMockReservedItems) Return(err error) *RepositoryMock {
	if mmReservedItems.mock.funcReservedItems != nil {
		mmReservedItems.mock.t.Fatalf("RepositoryMock.ReservedItems mock is already set by Set")
	}

	if mmReservedItems.defaultExpectation == nil {
		mmReservedItems.defaultExpectation = &RepositoryMockReservedItemsExpectation{mock: mmReservedItems.mock}
	}
	mmReservedItems.defaultExpectation.results = &RepositoryMockReservedItemsResults{err}
	return mmReservedItems.mock
}

// Set uses given function f to mock the Repository.ReservedItems method
func (mmReservedItems *mRepositoryMockReservedItems) Set(f func(ctx context.Context, orderID int64) (err error)) *RepositoryMock {
	if mmReservedItems.defaultExpectation != nil {
		mmReservedItems.mock.t.Fatalf("Default expectation is already set for the Repository.ReservedItems method")
	}

	if len(mmReservedItems.expectations) > 0 {
		mmReservedItems.mock.t.Fatalf("Some expectations are already set for the Repository.ReservedItems method")
	}

	mmReservedItems.mock.funcReservedItems = f
	return mmReservedItems.mock
}

// When sets expectation for the Repository.ReservedItems which will trigger the result defined by the following
// Then helper
func (mmReservedItems *mRepositoryMockReservedItems) When(ctx context.Context, orderID int64) *RepositoryMockReservedItemsExpectation {
	if mmReservedItems.mock.funcReservedItems != nil {
		mmReservedItems.mock.t.Fatalf("RepositoryMock.ReservedItems mock is already set by Set")
	}

	expectation := &RepositoryMockReservedItemsExpectation{
		mock:   mmReservedItems.mock,
		params: &RepositoryMockReservedItemsParams{ctx, orderID},
	}
	mmReservedItems.expectations = append(mmReservedItems.expectations, expectation)
	return expectation
}

// Then sets up Repository.ReservedItems return parameters for the expectation previously defined by the When method
func (e *RepositoryMockReservedItemsExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockReservedItemsResults{err}
	return e.mock
}

// ReservedItems implements loms.Repository
func (mmReservedItems *RepositoryMock) ReservedItems(ctx context.Context, orderID int64) (err error) {
	mm_atomic.AddUint64(&mmReservedItems.beforeReservedItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmReservedItems.afterReservedItemsCounter, 1)

	if mmReservedItems.inspectFuncReservedItems != nil {
		mmReservedItems.inspectFuncReservedItems(ctx, orderID)
	}

	mm_params := &RepositoryMockReservedItemsParams{ctx, orderID}

	// Record call args
	mmReservedItems.ReservedItemsMock.mutex.Lock()
	mmReservedItems.ReservedItemsMock.callArgs = append(mmReservedItems.ReservedItemsMock.callArgs, mm_params)
	mmReservedItems.ReservedItemsMock.mutex.Unlock()

	for _, e := range mmReservedItems.ReservedItemsMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReservedItems.ReservedItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReservedItems.ReservedItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmReservedItems.ReservedItemsMock.defaultExpectation.params
		mm_got := RepositoryMockReservedItemsParams{ctx, orderID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReservedItems.t.Errorf("RepositoryMock.ReservedItems got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReservedItems.ReservedItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmReservedItems.t.Fatal("No results are set for the RepositoryMock.ReservedItems")
		}
		return (*mm_results).err
	}
	if mmReservedItems.funcReservedItems != nil {
		return mmReservedItems.funcReservedItems(ctx, orderID)
	}
	mmReservedItems.t.Fatalf("Unexpected call to RepositoryMock.ReservedItems. %v %v", ctx, orderID)
	return
}

// ReservedItemsAfterCounter returns a count of finished RepositoryMock.ReservedItems invocations
func (mmReservedItems *RepositoryMock) ReservedItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReservedItems.afterReservedItemsCounter)
}

// ReservedItemsBeforeCounter returns a count of RepositoryMock.ReservedItems invocations
func (mmReservedItems *RepositoryMock) ReservedItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReservedItems.beforeReservedItemsCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.ReservedItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReservedItems *mRepositoryMockReservedItems) Calls() []*RepositoryMockReservedItemsParams {
	mmReservedItems.mutex.RLock()

	argCopy := make([]*RepositoryMockReservedItemsParams, len(mmReservedItems.callArgs))
	copy(argCopy, mmReservedItems.callArgs)

	mmReservedItems.mutex.RUnlock()

	return argCopy
}

// MinimockReservedItemsDone returns true if the count of the ReservedItems invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockReservedItemsDone() bool {
	for _, e := range m.ReservedItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReservedItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReservedItemsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReservedItems != nil && mm_atomic.LoadUint64(&m.afterReservedItemsCounter) < 1 {
		return false
	}
	return true
}

// MinimockReservedItemsInspect logs each unmet expectation
func (m *RepositoryMock) MinimockReservedItemsInspect() {
	for _, e := range m.ReservedItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.ReservedItems with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReservedItemsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReservedItemsCounter) < 1 {
		if m.ReservedItemsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.ReservedItems")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.ReservedItems with params: %#v", *m.ReservedItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReservedItems != nil && mm_atomic.LoadUint64(&m.afterReservedItemsCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.ReservedItems")
	}
}

type mRepositoryMockStocks struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockStocksExpectation
	expectations       []*RepositoryMockStocksExpectation

	callArgs []*RepositoryMockStocksParams
	mutex    sync.RWMutex
}

// RepositoryMockStocksExpectation specifies expectation struct of the Repository.Stocks
type RepositoryMockStocksExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockStocksParams
	results *RepositoryMockStocksResults
	Counter uint64
}

// RepositoryMockStocksParams contains parameters of the Repository.Stocks
type RepositoryMockStocksParams struct {
	ctx context.Context
	sku uint32
}

// RepositoryMockStocksResults contains results of the Repository.Stocks
type RepositoryMockStocksResults struct {
	sa1 []models.Stock
	err error
}

// Expect sets up expected params for Repository.Stocks
func (mmStocks *mRepositoryMockStocks) Expect(ctx context.Context, sku uint32) *mRepositoryMockStocks {
	if mmStocks.mock.funcStocks != nil {
		mmStocks.mock.t.Fatalf("RepositoryMock.Stocks mock is already set by Set")
	}

	if mmStocks.defaultExpectation == nil {
		mmStocks.defaultExpectation = &RepositoryMockStocksExpectation{}
	}

	mmStocks.defaultExpectation.params = &RepositoryMockStocksParams{ctx, sku}
	for _, e := range mmStocks.expectations {
		if minimock.Equal(e.params, mmStocks.defaultExpectation.params) {
			mmStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStocks.defaultExpectation.params)
		}
	}

	return mmStocks
}

// Inspect accepts an inspector function that has same arguments as the Repository.Stocks
func (mmStocks *mRepositoryMockStocks) Inspect(f func(ctx context.Context, sku uint32)) *mRepositoryMockStocks {
	if mmStocks.mock.inspectFuncStocks != nil {
		mmStocks.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Stocks")
	}

	mmStocks.mock.inspectFuncStocks = f

	return mmStocks
}

// Return sets up results that will be returned by Repository.Stocks
func (mmStocks *mRepositoryMockStocks) Return(sa1 []models.Stock, err error) *RepositoryMock {
	if mmStocks.mock.funcStocks != nil {
		mmStocks.mock.t.Fatalf("RepositoryMock.Stocks mock is already set by Set")
	}

	if mmStocks.defaultExpectation == nil {
		mmStocks.defaultExpectation = &RepositoryMockStocksExpectation{mock: mmStocks.mock}
	}
	mmStocks.defaultExpectation.results = &RepositoryMockStocksResults{sa1, err}
	return mmStocks.mock
}

// Set uses given function f to mock the Repository.Stocks method
func (mmStocks *mRepositoryMockStocks) Set(f func(ctx context.Context, sku uint32) (sa1 []models.Stock, err error)) *RepositoryMock {
	if mmStocks.defaultExpectation != nil {
		mmStocks.mock.t.Fatalf("Default expectation is already set for the Repository.Stocks method")
	}

	if len(mmStocks.expectations) > 0 {
		mmStocks.mock.t.Fatalf("Some expectations are already set for the Repository.Stocks method")
	}

	mmStocks.mock.funcStocks = f
	return mmStocks.mock
}

// When sets expectation for the Repository.Stocks which will trigger the result defined by the following
// Then helper
func (mmStocks *mRepositoryMockStocks) When(ctx context.Context, sku uint32) *RepositoryMockStocksExpectation {
	if mmStocks.mock.funcStocks != nil {
		mmStocks.mock.t.Fatalf("RepositoryMock.Stocks mock is already set by Set")
	}

	expectation := &RepositoryMockStocksExpectation{
		mock:   mmStocks.mock,
		params: &RepositoryMockStocksParams{ctx, sku},
	}
	mmStocks.expectations = append(mmStocks.expectations, expectation)
	return expectation
}

// Then sets up Repository.Stocks return parameters for the expectation previously defined by the When method
func (e *RepositoryMockStocksExpectation) Then(sa1 []models.Stock, err error) *RepositoryMock {
	e.results = &RepositoryMockStocksResults{sa1, err}
	return e.mock
}

// Stocks implements loms.Repository
func (mmStocks *RepositoryMock) Stocks(ctx context.Context, sku uint32) (sa1 []models.Stock, err error) {
	mm_atomic.AddUint64(&mmStocks.beforeStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmStocks.afterStocksCounter, 1)

	if mmStocks.inspectFuncStocks != nil {
		mmStocks.inspectFuncStocks(ctx, sku)
	}

	mm_params := &RepositoryMockStocksParams{ctx, sku}

	// Record call args
	mmStocks.StocksMock.mutex.Lock()
	mmStocks.StocksMock.callArgs = append(mmStocks.StocksMock.callArgs, mm_params)
	mmStocks.StocksMock.mutex.Unlock()

	for _, e := range mmStocks.StocksMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmStocks.StocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStocks.StocksMock.defaultExpectation.Counter, 1)
		mm_want := mmStocks.StocksMock.defaultExpectation.params
		mm_got := RepositoryMockStocksParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStocks.t.Errorf("RepositoryMock.Stocks got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStocks.StocksMock.defaultExpectation.results
		if mm_results == nil {
			mmStocks.t.Fatal("No results are set for the RepositoryMock.Stocks")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmStocks.funcStocks != nil {
		return mmStocks.funcStocks(ctx, sku)
	}
	mmStocks.t.Fatalf("Unexpected call to RepositoryMock.Stocks. %v %v", ctx, sku)
	return
}

// StocksAfterCounter returns a count of finished RepositoryMock.Stocks invocations
func (mmStocks *RepositoryMock) StocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocks.afterStocksCounter)
}

// StocksBeforeCounter returns a count of RepositoryMock.Stocks invocations
func (mmStocks *RepositoryMock) StocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStocks.beforeStocksCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Stocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStocks *mRepositoryMockStocks) Calls() []*RepositoryMockStocksParams {
	mmStocks.mutex.RLock()

	argCopy := make([]*RepositoryMockStocksParams, len(mmStocks.callArgs))
	copy(argCopy, mmStocks.callArgs)

	mmStocks.mutex.RUnlock()

	return argCopy
}

// MinimockStocksDone returns true if the count of the Stocks invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockStocksDone() bool {
	for _, e := range m.StocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocks != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		return false
	}
	return true
}

// MinimockStocksInspect logs each unmet expectation
func (m *RepositoryMock) MinimockStocksInspect() {
	for _, e := range m.StocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Stocks with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StocksMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		if m.StocksMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.Stocks")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Stocks with params: %#v", *m.StocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStocks != nil && mm_atomic.LoadUint64(&m.afterStocksCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.Stocks")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCancelOrderInspect()

		m.MinimockCreateOrderInspect()

		m.MinimockGetStatusInspect()

		m.MinimockListOrderInspect()

		m.MinimockOrderPayedInspect()

		m.MinimockReservedItemsInspect()

		m.MinimockStocksInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCancelOrderDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockGetStatusDone() &&
		m.MinimockListOrderDone() &&
		m.MinimockOrderPayedDone() &&
		m.MinimockReservedItemsDone() &&
		m.MinimockStocksDone()
}
